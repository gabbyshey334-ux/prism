const axios = require('axios');
const logger = require('../workers/logger');

/**
 * CE.SDK Service
 * Handles CreativeEditor SDK operations
 */
class CESDKService {
  constructor() {
    this.apiKey = process.env.CESDK_API_KEY || process.env.CESDK_LICENSE_KEY;
    this.baseURL = process.env.CESDK_API_URL || 'https://api.img.ly';
    this.version = 'v1';
    
    if (!this.apiKey) {
      console.warn('⚠️ CE.SDK API key not configured');
    }
  }

  /**
   * Check if CE.SDK is available
   * @returns {boolean}
   */
  isAvailable() {
    return !!this.apiKey;
  }

  /**
   * Get API key
   * @returns {string|null}
   */
  getApiKey() {
    return this.apiKey;
  }

  /**
   * Create a new design scene
   * @param {Object} params - Design parameters
   * @param {string} params.format - Design format (instagram_post, instagram_story, tiktok, youtube, linkedin)
   * @param {Object} params.dimensions - Custom dimensions {width, height}
   * @param {string} params.backgroundColor - Background color
   * @returns {Promise<Object>} Scene data
   */
  async createDesign({ format = 'instagram_post', dimensions = null, backgroundColor = '#FFFFFF' }) {
    if (!this.isAvailable()) {
      throw new Error('CE.SDK API key not configured');
    }

    // Get dimensions for format
    const formatDimensions = this.getFormatDimensions(format);
    const { width, height } = dimensions || formatDimensions;

    // Create base scene structure
    const scene = {
      version: '4.0.0',
      base: {
        width,
        height,
        backgroundColor
      },
      pages: [
        {
          id: 'page-1',
          layers: []
        }
      ]
    };

    return {
      scene,
      format,
      dimensions: { width, height },
      created_at: new Date().toISOString()
    };
  }

  /**
   * Render design to image
   * @param {Object} params - Render parameters
   * @param {Object} params.scene - Scene data
   * @param {string} params.format - Output format (png, jpeg)
   * @param {number} params.quality - Quality (1-100)
   * @param {number} params.scale - Scale factor
   * @returns {Promise<Object>} Render result with URL
   */
  async renderDesign({ scene, format = 'png', quality = 90, scale = 1 }) {
    if (!this.isAvailable()) {
      throw new Error('CE.SDK API key not configured');
    }

    try {
      // CE.SDK rendering typically happens client-side
      // For server-side rendering, you'd use the CE.SDK API
      // This is a placeholder that returns the scene for client-side rendering
      
      // In production, you might:
      // 1. Use CE.SDK server-side rendering API
      // 2. Use headless browser with CE.SDK
      // 3. Return scene data for client-side rendering
      
      // For now, we'll return scene data
      // The actual rendering URL would be generated client-side or via API
      
      return {
        success: true,
        scene,
        render_url: null, // Would be generated by CE.SDK API
        format,
        quality,
        scale,
        message: 'Scene ready for rendering. Use client-side CE.SDK or server API for actual rendering.'
      };
    } catch (error) {
      logger.error('CE.SDK render error:', error);
      throw new Error(`Failed to render design: ${error.message}`);
    }
  }

  /**
   * Apply template to scene
   * @param {Object} params - Template parameters
   * @param {Object} params.scene - Base scene
   * @param {Object} params.template - Template scene data
   * @returns {Promise<Object>} Merged scene
   */
  async applyTemplate({ scene, template }) {
    if (!scene || !template) {
      throw new Error('Scene and template are required');
    }

    // Merge template layers into scene
    const mergedScene = {
      ...scene,
      pages: scene.pages.map((page, index) => {
        const templatePage = template.pages?.[index] || template.pages?.[0];
        if (!templatePage) return page;

        return {
          ...page,
          layers: [
            ...(templatePage.layers || []),
            ...(page.layers || [])
          ]
        };
      })
    };

    return {
      scene: mergedScene,
      applied_at: new Date().toISOString()
    };
  }

  /**
   * Add text block to scene
   * @param {Object} params - Text block parameters
   * @param {Object} params.scene - Scene data
   * @param {string} params.text - Text content
   * @param {Object} params.position - Position {x, y}
   * @param {Object} params.style - Text style
   * @returns {Promise<Object>} Updated scene
   */
  async addTextBlock({ scene, text, position = { x: 0, y: 0 }, style = {} }) {
    if (!scene || !text) {
      throw new Error('Scene and text are required');
    }

    const textBlock = {
      type: 'text',
      id: `text-${Date.now()}`,
      text,
      position: {
        x: position.x || 0,
        y: position.y || 0
      },
      style: {
        fontSize: style.fontSize || 24,
        fontFamily: style.fontFamily || 'Arial',
        color: style.color || '#000000',
        fontWeight: style.fontWeight || 'normal',
        textAlign: style.textAlign || 'left',
        ...style
      },
      width: style.width || 200,
      height: style.height || 50
    };

    // Add to first page
    if (!scene.pages || scene.pages.length === 0) {
      scene.pages = [{ id: 'page-1', layers: [] }];
    }

    scene.pages[0].layers = scene.pages[0].layers || [];
    scene.pages[0].layers.push(textBlock);

    return {
      scene,
      block: textBlock,
      added_at: new Date().toISOString()
    };
  }

  /**
   * Add image block to scene
   * @param {Object} params - Image block parameters
   * @param {Object} params.scene - Scene data
   * @param {string} params.imageUrl - Image URL
   * @param {Object} params.position - Position {x, y}
   * @param {Object} params.size - Size {width, height}
   * @returns {Promise<Object>} Updated scene
   */
  async addImageBlock({ scene, imageUrl, position = { x: 0, y: 0 }, size = null }) {
    if (!scene || !imageUrl) {
      throw new Error('Scene and imageUrl are required');
    }

    const imageBlock = {
      type: 'image',
      id: `image-${Date.now()}`,
      imageUrl,
      position: {
        x: position.x || 0,
        y: position.y || 0
      },
      width: size?.width || 200,
      height: size?.height || 200,
      preserveAspectRatio: size?.preserveAspectRatio !== false
    };

    // Add to first page
    if (!scene.pages || scene.pages.length === 0) {
      scene.pages = [{ id: 'page-1', layers: [] }];
    }

    scene.pages[0].layers = scene.pages[0].layers || [];
    scene.pages[0].layers.push(imageBlock);

    return {
      scene,
      block: imageBlock,
      added_at: new Date().toISOString()
    };
  }

  /**
   * Add shape block to scene
   * @param {Object} params - Shape block parameters
   * @param {Object} params.scene - Scene data
   * @param {string} params.shapeType - Shape type (rectangle, circle, triangle)
   * @param {Object} params.position - Position {x, y}
   * @param {Object} params.size - Size {width, height}
   * @param {Object} params.style - Shape style
   * @returns {Promise<Object>} Updated scene
   */
  async addShapeBlock({ scene, shapeType = 'rectangle', position = { x: 0, y: 0 }, size = { width: 100, height: 100 }, style = {} }) {
    if (!scene) {
      throw new Error('Scene is required');
    }

    const shapeBlock = {
      type: 'shape',
      id: `shape-${Date.now()}`,
      shapeType,
      position: {
        x: position.x || 0,
        y: position.y || 0
      },
      width: size.width || 100,
      height: size.height || 100,
      style: {
        fillColor: style.fillColor || '#000000',
        strokeColor: style.strokeColor || 'transparent',
        strokeWidth: style.strokeWidth || 0,
        ...style
      }
    };

    // Add to first page
    if (!scene.pages || scene.pages.length === 0) {
      scene.pages = [{ id: 'page-1', layers: [] }];
    }

    scene.pages[0].layers = scene.pages[0].layers || [];
    scene.pages[0].layers.push(shapeBlock);

    return {
      scene,
      block: shapeBlock,
      added_at: new Date().toISOString()
    };
  }

  /**
   * Change background
   * @param {Object} params - Background parameters
   * @param {Object} params.scene - Scene data
   * @param {string} params.backgroundColor - Background color
   * @param {string} params.backgroundImage - Background image URL (optional)
   * @returns {Promise<Object>} Updated scene
   */
  async changeBackground({ scene, backgroundColor = null, backgroundImage = null }) {
    if (!scene) {
      throw new Error('Scene is required');
    }

    if (backgroundColor) {
      scene.base = scene.base || {};
      scene.base.backgroundColor = backgroundColor;
    }

    if (backgroundImage) {
      scene.base = scene.base || {};
      scene.base.backgroundImage = backgroundImage;
    }

    return {
      scene,
      updated_at: new Date().toISOString()
    };
  }

  /**
   * Delete block from scene
   * @param {Object} params - Delete parameters
   * @param {Object} params.scene - Scene data
   * @param {string} params.blockId - Block ID to delete
   * @returns {Promise<Object>} Updated scene
   */
  async deleteBlock({ scene, blockId }) {
    if (!scene || !blockId) {
      throw new Error('Scene and blockId are required');
    }

    // Remove block from all pages
    scene.pages = scene.pages.map(page => ({
      ...page,
      layers: (page.layers || []).filter(layer => layer.id !== blockId)
    }));

    return {
      scene,
      deleted_block_id: blockId,
      updated_at: new Date().toISOString()
    };
  }

  /**
   * Move block in scene
   * @param {Object} params - Move parameters
   * @param {Object} params.scene - Scene data
   * @param {string} params.blockId - Block ID
   * @param {Object} params.position - New position {x, y}
   * @returns {Promise<Object>} Updated scene
   */
  async moveBlock({ scene, blockId, position }) {
    if (!scene || !blockId || !position) {
      throw new Error('Scene, blockId, and position are required');
    }

    // Find and update block position
    scene.pages = scene.pages.map(page => ({
      ...page,
      layers: (page.layers || []).map(layer => {
        if (layer.id === blockId) {
          return {
            ...layer,
            position: {
              x: position.x,
              y: position.y
            }
          };
        }
        return layer;
      })
    }));

    return {
      scene,
      moved_block_id: blockId,
      updated_at: new Date().toISOString()
    };
  }

  /**
   * Extract blocks from scene
   * @param {Object} params - Extract parameters
   * @param {Object} params.scene - Scene data
   * @param {string} params.type - Block type filter (optional)
   * @returns {Promise<Array>} Extracted blocks
   */
  async extractBlocks({ scene, type = null }) {
    if (!scene) {
      throw new Error('Scene is required');
    }

    let blocks = [];

    // Extract from all pages
    scene.pages?.forEach(page => {
      blocks = blocks.concat(page.layers || []);
    });

    // Filter by type if specified
    if (type) {
      blocks = blocks.filter(block => block.type === type);
    }

    return {
      blocks,
      count: blocks.length,
      extracted_at: new Date().toISOString()
    };
  }

  /**
   * Inspect scene structure
   * @param {Object} params - Inspect parameters
   * @param {Object} params.scene - Scene data
   * @returns {Promise<Object>} Scene inspection data
   */
  async inspectScene({ scene }) {
    if (!scene) {
      throw new Error('Scene is required');
    }

    const blocks = await this.extractBlocks({ scene });
    const blockTypes = {};
    blocks.blocks.forEach(block => {
      blockTypes[block.type] = (blockTypes[block.type] || 0) + 1;
    });

    return {
      scene_id: scene.id || 'unknown',
      pages_count: scene.pages?.length || 0,
      total_blocks: blocks.count,
      block_types: blockTypes,
      dimensions: scene.base ? {
        width: scene.base.width,
        height: scene.base.height,
        backgroundColor: scene.base.backgroundColor
      } : null,
      has_background_image: !!scene.base?.backgroundImage,
      inspected_at: new Date().toISOString()
    };
  }

  /**
   * Apply content to template (replace placeholders)
   * @param {Object} params - Apply parameters
   * @param {Object} params.template - Template scene
   * @param {Object} params.content - Content data
   * @returns {Promise<Object>} Applied scene
   */
  async applyContentToTemplate({ template, content }) {
    if (!template || !content) {
      throw new Error('Template and content are required');
    }

    // Deep clone template
    const appliedScene = JSON.parse(JSON.stringify(template));

    // Replace placeholders in all layers
    appliedScene.pages = appliedScene.pages.map(page => ({
      ...page,
      layers: (page.layers || []).map(layer => {
        // Replace text placeholders
        if (layer.type === 'text' && layer.text) {
          layer.text = this.replacePlaceholders(layer.text, content);
        }

        // Replace image placeholders
        if (layer.type === 'image' && layer.imageUrl) {
          layer.imageUrl = this.replacePlaceholders(layer.imageUrl, content);
        }

        return layer;
      })
    }));

    return {
      scene: appliedScene,
      applied_content: content,
      applied_at: new Date().toISOString()
    };
  }

  /**
   * Replace placeholders in text
   * @param {string} text - Text with placeholders
   * @param {Object} content - Content data
   * @returns {string} Replaced text
   */
  replacePlaceholders(text, content) {
    if (!text || typeof text !== 'string') {
      return text;
    }

    // Replace {{placeholder}} with content values
    return text.replace(/\{\{(\w+)\}\}/g, (match, key) => {
      return content[key] || match;
    });
  }

  /**
   * Get format dimensions
   * @param {string} format - Format name
   * @returns {Object} Dimensions {width, height}
   */
  getFormatDimensions(format) {
    const formats = {
      instagram_post: { width: 1080, height: 1080 },
      instagram_story: { width: 1080, height: 1920 },
      tiktok: { width: 1080, height: 1920 },
      youtube: { width: 1280, height: 720 },
      linkedin: { width: 1200, height: 627 },
      facebook_post: { width: 1200, height: 630 },
      twitter: { width: 1200, height: 675 }
    };

    return formats[format] || formats.instagram_post;
  }

  /**
   * Upload rendered image to Firebase Storage
   * @param {Buffer} imageBuffer - Image buffer
   * @param {string} filename - Filename
   * @param {string} contentType - Content type
   * @returns {Promise<string>} Public URL
   */
  async uploadToStorage(imageBuffer, filename, contentType = 'image/png') {
    try {
      const { getStorage } = require('../config/firebase');
      const storage = getStorage();
      
      if (!storage) {
        throw new Error('Firebase Storage not configured');
      }
      
      const bucket = storage.bucket();
      const file = bucket.file(`cesdk/renders/${filename}`);

      await file.save(imageBuffer, {
        metadata: {
          contentType
        },
        public: true
      });

      // Make file public
      await file.makePublic();

      // Get public URL
      const publicUrl = `https://storage.googleapis.com/${bucket.name}/${file.name}`;

      return publicUrl;
    } catch (error) {
      logger.error('Firebase Storage upload error:', error);
      throw new Error(`Failed to upload to storage: ${error.message}`);
    }
  }
}

module.exports = new CESDKService();

